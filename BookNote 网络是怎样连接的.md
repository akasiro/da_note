# chapter1 浏览器生成消息
## 1.1 生成HTTP请求消息
### 1.1.1 探索之旅从输入网址开始
+ URL的各种格式
+ ![[url的各种格式.png]]
### 1.1.2浏览器先要解析URL
![[浏览器解释URL的过程.png]]
### 1.1.3 省略文件名的情况
+ 1. 有目录名省略文件名：服务器预先设置默认访问的文件名，大多数为index.html或者default.htm
+ 2. 只有域名后加/：访问/目录下的默认文件
+ 3. 只有域名：根目录下的默认文件
### 1.1.4 http的基本思路
![[http的基本思路.png]]
+ 客户端向服务端发送消息
	+ 消息内容：
		+ ”对什么“：URI （Uniform Resource Identifier）统一资源标识符
			+ 一般是存放网页数据的文件名或者CGI程序
			+ 实际上，这个文件在 Web 服务器上未必是真实存在的，因为 Web 服务器可以通过重写规则对虚拟的 URI 进行映射。
		+ ”进行什么操作“：方法
			+ ![[Http的主要方法.png]]
+ Web服务器对消息内容解析，返回响应码和内容
	+ Get方法：将读取数据返回在内容中
	+ Post方法：URI会指向Web服务器中运行的应用程序，例如index.php
### 1.1.5 生成http请求消息
![[http消息格式.png]]
### 1.1.6 发送请求后会收到响应
![[http状态码.png]]
1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。例如，网页上有图片就需要发送多条请求
## 1.2 向DNS服务器查询Web服务器的IP地址
+ 尽管浏览器能够解析网址并生成 HTTP 消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。发送消息的功能对于所有的应用程序来说都是通用的，因此让操作系统来 实现这一功能，其他应用程序委托操作系统来进行操作，这是一个比较合 理的做法。
+ 委托操作系统发送消息时，必须要提供的不 是通信对象的域名，而是它的 IP 地址。
### 1.2.1 IP地址的基本知识
#### TCP/IP 的思路
![[TCP_IP基本思路.png]]
![[IP地址的表示方法.png]]
### 1.2.2 域名和IP地址并用的理由
### 1.2.3 Socket库提供查询IP地址的功能
+ DNS解析器：
	+ 计算机上的DNS解析器（DNS客户端）向DNS服务器发送查询并接受消息。
	+ 解析器实际是一段程序，包含在操作系统的Socket库
+ Socket库
	+ 库：一堆通用程序组件的集合
	+ Socket 库是用于调用网络功能的程序组件集合。
### 1.2.4 通过解析器向DNS服务器发出查询
![[解析器的调用方法.png]]
根据域名查询 IP 地址时，浏览器会使用 Socket 库中的解析器。
### 1.2.5 解析器的内部原理
![[调用解析器时计算机内部的工作流程.png]]
## 1.3 全世界DNS服务器的大接力
### 1.3.1 DNS服务器的基本工作
![[DNS服务器的基本工作.png]]
### 1.3.2 域名的层次结构
#### 信息是如何在 DNS 服务器上注册并保存的
1. DNS 服务器中的所有信息都是按照域名以分层次的结构来保存的。
	+在域名中，越靠右的 位置表示其层级越高，比如 www.lab.glasscom.com 这个域名如果按照公司 里的组织结构来说，大概就是“com 事业集团 glasscom 部 lab 科的 www” 这样。
### 1.3.3 寻找相应的DNS服务器并获取IP地址
+ 将根域的地址（”.“）保存在所有DNS服务器
+ 根域保存着com, jp等DNS服务器信息
+ com服务器保存着下级域的服务器信息
+ ![[找到目标的DNS服务器.png]]
+ ### 1.3.4 通过缓存加快DNS服务器的响应
## 1.4 委托协议栈发送消息
### 1.4.1 数据收发操作概览
向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调 用 Socket 库中的程序组件。
![[数据通过类似关到的结构来流动.png]]
+ 建立管道的关键在于管道两端的数据出入口（出入口叫套接字）：
	+ 服务器创建套接字，等待客户端向该套接字连接管道（一般服务器启动后就创建好）
	+ 客户端创建一个套接字延伸出管道
	+ 数据发送完毕断开管道。断开可以由客户端或服务器任意一方发起。
+ 这些操作都是委托操作系统的协议栈来代劳，socket库是执行委托这一动作。
### 1.4.2 创建套接字阶段
+ 调用 Socket 库中的 socket 程序组件创建套接字
	+ 应用程序是通过“描述符”这一类似号码牌的东西来识别套接字的。
	+ 描述符是区分不同套接字的”号码牌“
+ ![[客户端和服务器之间收发数据操作.png]]

### 1.4.3 连接阶段：把管道接上去
+ 应用程序通过调用 Socket 库中的名为 connect 的程序组 件委托协议栈将客户端创建的套接字与服务器那边的 套接字连接起来
+ connect的三个参数
	+ 描述符
	+ 服务器IP地址
	+ 端口号，识别要连接哪个套接字。服务器上所使用的端口号是根据应用的种类事先规定好的，仅 此而已。比如 Web 是 80 号端口，电子邮件是 25 号端口
		+ 客户端在创建套接字时，协议栈会为这个套接 字随便分配一个端口号。当协议栈执行连接操作时，会将这个随 便分配的端口号通知给服务器。
+ 描述符:应用程序用来识别套接字的机制  
+ IP 地址和端口号:客户端和服务器之间用来识别对方套接字的机制
### 1.4.4 通信阶段：传递消息
### 1.4.5 断开阶段：收发数据结束
+ Web 使用的 HTTP 协议规定，当 Web 服务器发送完 响应消息之后，应该主动执行断开操作
+ 如果一个网页包含多张图片，重复连接和断开效率低，因此可以在一次连接中收发多个请求和响应


# Chapter2 用电信号传输TCP/IP数据 --探索协议栈和网卡
## 2.1 创建套接字
### 2.1.1 协议栈的内部结构
![[TCP IP软件采用分层结构.png]]
+ Socket库里的解析器就是DNS解析器
+ 浏览器、邮件等一般应用程序收发数据时用 TCP协议; DNS 查询等收发较短的控制数据时用 UDP协议。
### 2.1.2 套接字的实体就是通信控制信息
+ 存放控制信息的内存空间--可以看做是套接字的实体
	+ 控制信息：例如通信对象的IP地址、端口号、通信操作的进行状态
		+ 通信操作的进行状态：发送数据过了多久，是否有响应
+ 协议栈是根据套接字中记录的控制信息来工作的。
+ windows查看套接字内容
```cmd
netstat -ano
# a表示显示所有套接字
# n显示IP地址和端口号
# o显示使用套接字的程序pid
```

```output
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)     rhiwat shiwat    pid   epid  state    options

tcp4       0      0  172.16.186.65.55276    10.32.255.92.http      SYN_SENT    131072 131072  71855      0 0x0104 0x00000100

tcp4       0      0  172.16.186.65.55258    10.44.137.149.8093     ESTABLISHED 262144 131670  67667      0 0x0182 0x00000000
```


### 2.1.3 调用socket时的操作
![[信息收发操作.png.png]]
+ 应用程序调用 socket 申 请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作
	+ 创建套接字时，首先分配一个套接字所需的内存空间，然后向其 中写入初始状态。
	+ 接下来，需要将表示这个套接字的描述符告知应用程序。
	+ 收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。

## 2.2 连接服务器
### 2.2.1 连接是什么意思
连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作

### 2.2.2 负责保存控制信息的头部
+ 通信操作中使用的控制信息分为两类。
	+ **头部**：客户端和服务端相互联络时交换的控制信息
		+ 表中信息是固定的，在连接、收发、断开都需要提供，放在网络包的开头
		+ ![[TCP头部格式.png]]
	+ **控制协议栈操作的信息**：应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会 根据这些信息来执行每一步的操作。
		+ 不同操作系统是不同的
### 2.2.3 连接操作的实际过程
+ 应用程序调用Socket库的connect，connect(<描述符>,<服务器IP地址和端口号>,...)，这些信息传递到协议栈的TCP模块，TCP模块与服务器的TCP模块交换控制信息：
	+ 客户端TCP模块创建标志链接控制信息的头部，将头部中的控制位SYN设置为1，表示连接
	+ TCP模块将信息传递给IP模块并委托进行发送，IP模块执行网络包发送操作
	+ 网络包达到服务器，IP模块传递给TCP模块
	+ TCP模块根据TCP头部中的信息找到端口号对应的套接字，套接字状态改为正在连接
	+ 服务器TCP返回响应，过程和客户端一样，SYN设为1，同时需要将ACK控制位设为1，表示收到网络包
	+ 网络包返回客户端，通过IP模块到达TCP模块，如果SYN为1表示连接成功，向套接字中写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕
	+ 客户端将ACK设为1并发回服务器表示收到
## 2.3 收发数据
### 2.3.1 将HTTP请求消息交给协议栈
+ 应用程序调用write将要发送的数据交给协议栈
+ 协议栈收到数据执行发送操作：
	+ 协议栈并不关注数据的内容（二进制字节序列），应用程序可以选择一次将所有数据传给协议栈，也可以逐字节或逐行传递
	+ 先将数据存放在内部的发送缓存区，达到一定的条件再发送（因为协议栈并不知道信息传完了）
		+ 条件1（为了网络效率，避免大量小包）：网络包能容纳的数据长度，MTU，当数据长度超过或者接近MSS就可以发送
			+ MTU:一个网络包的最大长度，以太网中一般为 1500 字节。 
			+ MSS:除去头部之后，一个网络包所能容纳的 TCP 数据的最大长度。
			+ ![[MTU和MSS.png]]
		+ 条件2（避免延迟）：时间，经过一定时间就算没有达到MSS也会发送
		+ 条件1和2的权衡在不同操作系统存在差异
		+ 应用程序也可以控制发送时机，可以选择直接发送
### 2.3.2 对较大的数据进行拆分
如果数据超过MSS长度，则不等待，将数据以MSS长度为单位拆分
### 2.3.3 使用ACK号确认网络包已收到
+ 通过“序号”和“ACK 号”可以确认接收方是否收到了网络包。
	+ 返回 ACK 号时，除了要设置 ACK 号的值以外，还需要将控制位中的 ACK 比特设为 1，这代表 ACK 号字段有效，接收方也就可以知道这个网 络包是用来告知 ACK 号的。
	+ 拆分数据时TCP算好每块数据相当于从头开始的第几个字节，将算好的字节数写入TCP头部
	+ 实际通信中序号不是从1开始而是一个随机的初始数，防止攻击。在连接时需要将初始值告知通信对象，在SYN控制位设为1的同时设置序号字段，即为初始值
+ TCP这个机制保证没有收到包就重新发送，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误 就直接丢弃相应的包。
	+ 如果发生网络中断、服务器宕机等问题，那么 无论 TCP 怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因 此 TCP 会在尝试几次重传无效之后强制结束通信，并向应用程序报错。
### 2.3.4 根据网络包平均往返时间调整ACK号等待时间
+ 返回ACK号的等待时间（超时时间）
	+ TCP 会在发送数据 的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应 延长等待时间;相对地，如果 ACK 号马上就能返回，则相应缩短等待时间
### 2.3.5 使用窗口有效管理ACK号
+ 为了减少等待ACK号时间的浪费，在发送一个包后直接发送后续的一系列包
+ 接收方会暂存缓存区，接收方会通过TCP头部的窗口字段将自己能接收的数据量告知发送方，避免缓存溢出。
![[滑动窗口与接收缓冲区.png]]
### 2.3.6 ACK与窗口合并

### 2.3.7 接收HTTP响应信息

## 2.4 从服务器断开并删除套接字
### 2.4.1 数据发送完毕后断开连接
服务器一方的应用程序会 调用 Socket 库的 close 程序。然后，服务器的协议栈会生成包含断开信息 的 TCP 头部，具体来说就是将控制位中的 FIN 比特设为 1。接下来，协议 栈会委托 IP 模块向客户端发送数据(图 2.12 1)。同时，服务器的套接字 中也会记录下断开操作的相关信息。
当收到服务器发来的 FIN 为 1 的 TCP 头部时， 客户端的协议栈会将自己的套接字标记为进入断开操作状态。然后，为 了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号
### 2.4.2 删除套接字
不会立刻删除，而是等待一段时间后
### 2.4.3 数据收发操作小结
![[TCP的整体流程.png]]
## 2.5 IP与以太网的包收发操作
### 2.5.1 包的基本知识
+ 包：
	+ 头部
		+ MAC头部：以太网控制信息（只有以太网包有）
		+ IP头部：IP控制信息
	+ 数据
+ 基本结构：终端节点（发送方）$\rightarrow$ 最近的转发设备$\rightarrow$ ...$\rightarrow$ 转发设备 $\rightarrow$ 终端节点（接收方）